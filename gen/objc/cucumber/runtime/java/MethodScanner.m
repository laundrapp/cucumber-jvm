//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Salton/Documents/Projects/cucumber-jvm/java/src/main/java/cucumber/runtime/java/MethodScanner.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "cucumber/api/java/After.h"
#include "cucumber/api/java/Before.h"
#include "cucumber/runtime/ClassFinder.h"
#include "cucumber/runtime/CucumberException.h"
#include "cucumber/runtime/Utils.h"
#include "cucumber/runtime/io/MultiLoader.h"
#include "cucumber/runtime/java/JavaBackend.h"
#include "cucumber/runtime/java/MethodScanner.h"
#include "cucumber/runtime/java/StepDefAnnotation.h"
#include "java/lang/annotation/Annotation.h"
#include "java/lang/reflect/Method.h"
#include "java/util/Collection.h"
#include "java/util/List.h"

@interface CCBMethodScanner () {
 @public
  id<CCBRClassFinder> classFinder_;
}

- (void)validateMethodWithJavaLangReflectMethod:(JavaLangReflectMethod *)method
                                   withIOSClass:(IOSClass *)glueCodeClass;

- (jboolean)isHookAnnotationWithJavaLangAnnotationAnnotation:(id<JavaLangAnnotationAnnotation>)annotation;

- (jboolean)isStepdefAnnotationWithJavaLangAnnotationAnnotation:(id<JavaLangAnnotationAnnotation>)annotation;

@end

J2OBJC_FIELD_SETTER(CCBMethodScanner, classFinder_, id<CCBRClassFinder>)

__attribute__((unused)) static void CCBMethodScanner_validateMethodWithJavaLangReflectMethod_withIOSClass_(CCBMethodScanner *self, JavaLangReflectMethod *method, IOSClass *glueCodeClass);

__attribute__((unused)) static jboolean CCBMethodScanner_isHookAnnotationWithJavaLangAnnotationAnnotation_(CCBMethodScanner *self, id<JavaLangAnnotationAnnotation> annotation);

__attribute__((unused)) static jboolean CCBMethodScanner_isStepdefAnnotationWithJavaLangAnnotationAnnotation_(CCBMethodScanner *self, id<JavaLangAnnotationAnnotation> annotation);

@implementation CCBMethodScanner

- (instancetype __nonnull)initWithCCBRClassFinder:(id<CCBRClassFinder>)classFinder {
  CCBMethodScanner_initWithCCBRClassFinder_(self, classFinder);
  return self;
}

- (void)scanWithCCBJavaBackend:(CCBJavaBackend *)javaBackend
              withJavaUtilList:(id<JavaUtilList>)gluePaths {
  for (NSString * __strong gluePath in nil_chk(gluePaths)) {
    for (IOSClass * __strong glueCodeClass in nil_chk([((id<CCBRClassFinder>) nil_chk(classFinder_)) getDescendantsWithIOSClass:NSObject_class_() withNSString:CCBMultiLoader_packageNameWithNSString_(gluePath)])) {
      while (glueCodeClass != nil && glueCodeClass != NSObject_class_() && !CCBRUtils_isInstantiableWithIOSClass_(glueCodeClass)) {
        glueCodeClass = [glueCodeClass getSuperclass];
      }
      if (glueCodeClass != nil && glueCodeClass != NSObject_class_()) {
        {
          IOSObjectArray *a__ = [glueCodeClass getMethods];
          JavaLangReflectMethod * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
          JavaLangReflectMethod * const *e__ = b__ + a__->size_;
          while (b__ < e__) {
            JavaLangReflectMethod *method = *b__++;
            if ([((JavaLangReflectMethod *) nil_chk(method)) getDeclaringClass] != NSObject_class_()) {
              [self scanWithCCBJavaBackend:javaBackend withJavaLangReflectMethod:method withIOSClass:glueCodeClass];
            }
          }
        }
      }
    }
  }
}

- (void)scanWithCCBJavaBackend:(CCBJavaBackend *)javaBackend
     withJavaLangReflectMethod:(JavaLangReflectMethod *)method
                  withIOSClass:(IOSClass *)glueCodeClass {
  IOSObjectArray *methodAnnotations = [((JavaLangReflectMethod *) nil_chk(method)) getAnnotations];
  {
    IOSObjectArray *a__ = methodAnnotations;
    id<JavaLangAnnotationAnnotation> const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    id<JavaLangAnnotationAnnotation> const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      id<JavaLangAnnotationAnnotation> annotation = *b__++;
      if (CCBMethodScanner_isHookAnnotationWithJavaLangAnnotationAnnotation_(self, annotation)) {
        CCBMethodScanner_validateMethodWithJavaLangReflectMethod_withIOSClass_(self, method, glueCodeClass);
        [((CCBJavaBackend *) nil_chk(javaBackend)) addHookWithJavaLangAnnotationAnnotation:annotation withJavaLangReflectMethod:method];
      }
      else if (CCBMethodScanner_isStepdefAnnotationWithJavaLangAnnotationAnnotation_(self, annotation)) {
        CCBMethodScanner_validateMethodWithJavaLangReflectMethod_withIOSClass_(self, method, glueCodeClass);
        [((CCBJavaBackend *) nil_chk(javaBackend)) addStepDefinitionWithJavaLangAnnotationAnnotation:annotation withJavaLangReflectMethod:method];
      }
    }
  }
}

- (void)validateMethodWithJavaLangReflectMethod:(JavaLangReflectMethod *)method
                                   withIOSClass:(IOSClass *)glueCodeClass {
  CCBMethodScanner_validateMethodWithJavaLangReflectMethod_withIOSClass_(self, method, glueCodeClass);
}

- (jboolean)isHookAnnotationWithJavaLangAnnotationAnnotation:(id<JavaLangAnnotationAnnotation>)annotation {
  return CCBMethodScanner_isHookAnnotationWithJavaLangAnnotationAnnotation_(self, annotation);
}

- (jboolean)isStepdefAnnotationWithJavaLangAnnotationAnnotation:(id<JavaLangAnnotationAnnotation>)annotation {
  return CCBMethodScanner_isStepdefAnnotationWithJavaLangAnnotationAnnotation_(self, annotation);
}

- (void)dealloc {
  RELEASE_(classFinder_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, 3, -1, -1 },
    { NULL, "V", 0x1, 1, 4, -1, 5, -1, -1 },
    { NULL, "V", 0x2, 6, 7, -1, 8, -1, -1 },
    { NULL, "Z", 0x2, 9, 10, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 11, 10, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithCCBRClassFinder:);
  methods[1].selector = @selector(scanWithCCBJavaBackend:withJavaUtilList:);
  methods[2].selector = @selector(scanWithCCBJavaBackend:withJavaLangReflectMethod:withIOSClass:);
  methods[3].selector = @selector(validateMethodWithJavaLangReflectMethod:withIOSClass:);
  methods[4].selector = @selector(isHookAnnotationWithJavaLangAnnotationAnnotation:);
  methods[5].selector = @selector(isStepdefAnnotationWithJavaLangAnnotationAnnotation:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "classFinder_", "LCCBRClassFinder;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LCCBRClassFinder;", "scan", "LCCBJavaBackend;LJavaUtilList;", "(Lcucumber/runtime/java/JavaBackend;Ljava/util/List<Ljava/lang/String;>;)V", "LCCBJavaBackend;LJavaLangReflectMethod;LIOSClass;", "(Lcucumber/runtime/java/JavaBackend;Ljava/lang/reflect/Method;Ljava/lang/Class<*>;)V", "validateMethod", "LJavaLangReflectMethod;LIOSClass;", "(Ljava/lang/reflect/Method;Ljava/lang/Class<*>;)V", "isHookAnnotation", "LJavaLangAnnotationAnnotation;", "isStepdefAnnotation" };
  static const J2ObjcClassInfo _CCBMethodScanner = { "MethodScanner", "cucumber.runtime.java", ptrTable, methods, fields, 7, 0x0, 6, 1, -1, -1, -1, -1, -1 };
  return &_CCBMethodScanner;
}

@end

void CCBMethodScanner_initWithCCBRClassFinder_(CCBMethodScanner *self, id<CCBRClassFinder> classFinder) {
  NSObject_init(self);
  JreStrongAssign(&self->classFinder_, classFinder);
}

CCBMethodScanner *new_CCBMethodScanner_initWithCCBRClassFinder_(id<CCBRClassFinder> classFinder) {
  J2OBJC_NEW_IMPL(CCBMethodScanner, initWithCCBRClassFinder_, classFinder)
}

CCBMethodScanner *create_CCBMethodScanner_initWithCCBRClassFinder_(id<CCBRClassFinder> classFinder) {
  J2OBJC_CREATE_IMPL(CCBMethodScanner, initWithCCBRClassFinder_, classFinder)
}

void CCBMethodScanner_validateMethodWithJavaLangReflectMethod_withIOSClass_(CCBMethodScanner *self, JavaLangReflectMethod *method, IOSClass *glueCodeClass) {
  if (![((IOSClass *) nil_chk([((JavaLangReflectMethod *) nil_chk(method)) getDeclaringClass])) isAssignableFrom:glueCodeClass]) {
    @throw create_CCBRCucumberException_initWithNSString_(NSString_java_formatWithNSString_withNSObjectArray_(@"%s isn't assignable from %s", [IOSObjectArray arrayWithObjects:(id[]){ [method getDeclaringClass], glueCodeClass } count:2 type:NSObject_class_()]));
  }
  if (![((IOSClass *) nil_chk(glueCodeClass)) isEqual:[method getDeclaringClass]]) {
    @throw create_CCBRCucumberException_initWithNSString_(NSString_java_formatWithNSString_withNSObjectArray_(@"You're not allowed to extend classes that define Step Definitions or hooks. %s extends %s", [IOSObjectArray arrayWithObjects:(id[]){ glueCodeClass, [method getDeclaringClass] } count:2 type:NSObject_class_()]));
  }
}

jboolean CCBMethodScanner_isHookAnnotationWithJavaLangAnnotationAnnotation_(CCBMethodScanner *self, id<JavaLangAnnotationAnnotation> annotation) {
  IOSClass *annotationClass = [((id<JavaLangAnnotationAnnotation>) nil_chk(annotation)) annotationType];
  return [((IOSClass *) nil_chk(annotationClass)) isEqual:CCBBefore_class_()] || [annotationClass isEqual:CCBAfter_class_()];
}

jboolean CCBMethodScanner_isStepdefAnnotationWithJavaLangAnnotationAnnotation_(CCBMethodScanner *self, id<JavaLangAnnotationAnnotation> annotation) {
  IOSClass *annotationClass = [((id<JavaLangAnnotationAnnotation>) nil_chk(annotation)) annotationType];
  return [((IOSClass *) nil_chk(annotationClass)) getAnnotationWithIOSClass:CCBStepDefAnnotation_class_()] != nil;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(CCBMethodScanner)
